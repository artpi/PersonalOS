<?php
/**
 * Handles automatic email responses for new incoming emails.
 *
 * @package PersonalOS
 */

class OpenAI_Email_Responder {
	/**
	 * Parent OpenAI module.
	 *
	 * @var OpenAI_Module
	 */
	protected $module;

	/**
	 * Constructor.
	 *
	 * @param OpenAI_Module $module OpenAI module instance.
	 */
	public function __construct( OpenAI_Module $module ) {
		$this->module = $module;
		add_action( 'pos_imap_new_email', array( $this, 'handle_new_email' ), 20, 1 );
	}

	/**
	 * Handle new incoming emails and respond using the AI conversation completion.
	 *
	 * @param array $email_data Email data from the IMAP module.
	 */
	public function handle_new_email( array $email_data ): void {
		$recipient = $this->get_reply_address( $email_data );
		if ( empty( $recipient ) ) {
			$this->module->log( 'Auto-reply skipped: no valid recipient.' );
			return;
		}

		$imap_module = POS::get_module_by_id( 'imap' );
		if ( ! $imap_module || ! method_exists( $imap_module, 'send_email' ) ) {
			$this->module->log( 'Auto-reply skipped: IMAP module not available.', E_USER_WARNING );
			return;
		}

		$backscroll = $this->build_backscroll_for_email( $email_data );

		$assistant_reply = '';
		$used_fallback   = false;

		$conversation = $this->module->complete_backscroll( $backscroll );
		if ( is_wp_error( $conversation ) ) {
			$this->module->log( 'Auto-reply AI failure: ' . $conversation->get_error_message(), E_USER_ERROR );
			$used_fallback = true;
		} else {
			$assistant_reply = $this->extract_assistant_reply( $conversation );
			if ( '' === $assistant_reply ) {
				$this->module->log( 'Auto-reply AI returned no assistant message.', E_USER_WARNING );
				$used_fallback = true;
			}
		}

		if ( $used_fallback ) {
			$assistant_reply = 'Thank you for your message.';
		}

		$subject = $this->prepare_subject( isset( $email_data['subject'] ) ? $email_data['subject'] : '' );
		$body    = $this->compose_reply_body( $assistant_reply, $email_data );
		$headers = $this->prepare_headers( $email_data );

		$sent = $imap_module->send_email( $recipient, $subject, $body, $headers );

		if ( $sent ) {
			$this->module->log( ( $used_fallback ? 'Fallback auto-reply sent to ' : 'AI auto-reply sent to ' ) . $recipient );
		} else {
			$this->module->log( 'Auto-reply failed for ' . $recipient, E_USER_ERROR );
		}
	}

	/**
	 * Build minimal backscroll containing the full email content for the AI.
	 *
	 * @param array $email_data Email data from the IMAP module.
	 * @return array Backscroll messages.
	 */
	private function build_backscroll_for_email( array $email_data ): array {
		$from_email = isset( $email_data['from'] ) ? $email_data['from'] : '';
		$from_name  = isset( $email_data['from_name'] ) ? $email_data['from_name'] : '';
		$display    = $from_email;

		if ( '' !== $from_name && '' !== $from_email ) {
			$display = $from_name . ' <' . $from_email . '>';
		} elseif ( '' !== $from_name ) {
			$display = $from_name;
		}

		$lines   = array();
		$lines[] = 'From: ' . ( '' !== $display ? $display : 'unknown sender' );

		if ( ! empty( $email_data['subject'] ) ) {
			$lines[] = 'Subject: ' . trim( (string) $email_data['subject'] );
		}

		$lines[] = 'Body:';
		$lines[] = isset( $email_data['body'] ) && '' !== trim( (string) $email_data['body'] )
			? (string) $email_data['body']
			: '(No body content provided.)';

		return array(
			array(
				'role'    => 'user',
				'content' => $this->normalize_backscroll_content( implode( "\n", $lines ) ),
			),
		);
	}

	/**
	 * Prepare the response subject, ensuring a proper "Re:" prefix.
	 *
	 * @param string $subject Original subject.
	 * @return string Reply subject.
	 */
	private function prepare_subject( string $subject ): string {
		$subject = trim( $subject );
		if ( '' === $subject ) {
			return 'Re: (No Subject)';
		}
		if ( preg_match( '/^Re:/i', $subject ) ) {
			return $subject;
		}
		return 'Re: ' . $subject;
	}

	/**
	 * Compose the response body by combining AI output with the original email content.
	 *
	 * @param string $assistant_reply Reply generated by the assistant or fallback.
	 * @param array  $email_data      Email data from the IMAP module.
	 * @return string Response body.
	 */
	private function compose_reply_body( string $assistant_reply, array $email_data ): string {
		$assistant_reply = trim( $assistant_reply );
		if ( '' === $assistant_reply ) {
			$assistant_reply = 'Thank you for your message.';
		}

		$body          = $assistant_reply;
		$original_body = isset( $email_data['body'] ) ? (string) $email_data['body'] : '';

		if ( '' !== trim( $original_body ) ) {
			$body .= "\n\n" . $original_body;
		}

		return rtrim( $body ) . "\n";
	}

	/**
	 * Prepare headers to ensure replies thread correctly.
	 *
	 * @param array $email_data Email data from the IMAP module.
	 * @return array List of headers.
	 */
	private function prepare_headers( array $email_data ): array {
		$headers = array();

		if ( ! empty( $email_data['message_id'] ) ) {
			$headers[] = 'In-Reply-To: ' . $email_data['message_id'];
			$references = ! empty( $email_data['references'] ) ? $email_data['references'] . ' ' . $email_data['message_id'] : $email_data['message_id'];
			$references = preg_replace( '/\s+/', ' ', trim( $references ) );
			$headers[] = 'References: ' . $references;
		}

		if ( ! empty( $email_data['reply_to'] ) ) {
			$reply_to = is_array( $email_data['reply_to'] ) ? $email_data['reply_to'] : explode( ',', $email_data['reply_to'] );
			$reply_to = array_filter( array_map( 'trim', $reply_to ) );
			if ( ! empty( $reply_to ) ) {
				$headers[] = 'Reply-To: ' . implode( ', ', $reply_to );
			}
		}

		return $headers;
	}

	/**
	 * Determine the address to reply to.
	 *
	 * @param array $email_data Email data from the IMAP module.
	 * @return string Reply address.
	 */
	private function get_reply_address( array $email_data ): string {
		if ( ! empty( $email_data['reply_to'] ) ) {
			$reply_to = is_array( $email_data['reply_to'] ) ? $email_data['reply_to'] : explode( ',', $email_data['reply_to'] );
			$reply_to = array_filter( array_map( 'trim', $reply_to ) );
			if ( ! empty( $reply_to ) ) {
				return sanitize_email( reset( $reply_to ) );
			}
		}
		return isset( $email_data['from'] ) ? sanitize_email( $email_data['from'] ) : '';
	}

	/**
	 * Extract the latest assistant reply from the completed backscroll.
	 *
	 * @param array $conversation Conversation history returned from complete_backscroll.
	 * @return string Assistant reply content.
	 */
	private function extract_assistant_reply( array $conversation ): string {
		foreach ( array_reverse( $conversation ) as $message ) {
			if ( is_array( $message ) && isset( $message['role'], $message['content'] ) ) {
				if ( 'assistant' !== $message['role'] ) {
					continue;
				}
				return trim( is_string( $message['content'] ) ? $message['content'] : wp_json_encode( $message['content'] ) );
			}

			if ( is_object( $message ) && isset( $message->role, $message->content ) ) {
				if ( 'assistant' !== $message->role ) {
					continue;
				}
				return trim( is_string( $message->content ) ? $message->content : wp_json_encode( $message->content ) );
			}
		}

		return '';
	}

	/**
	 * Normalise conversation text for the backscroll.
	 *
	 * @param string $content     Text content.
	 * @param int    $max_length  Maximum length in characters.
	 * @return string Normalised content.
	 */
	private function normalize_backscroll_content( string $content, int $max_length = 4000 ): string {
		$content = str_replace( array( "\r\n", "\r" ), "\n", $content );
		$content = preg_replace( '/\n{3,}/', "\n\n", $content );
		$content = trim( $content );

		if ( function_exists( 'mb_strlen' ) ) {
			if ( mb_strlen( $content, 'UTF-8' ) > $max_length ) {
				$content = mb_substr( $content, 0, $max_length, 'UTF-8' ) . "\n\n[truncated]";
			}
		} elseif ( strlen( $content ) > $max_length ) {
			$content = substr( $content, 0, $max_length ) . "\n\n[truncated]";
		}

		return $content;
	}
}
